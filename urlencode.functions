# This approach is overly conservative, but it works
urlencode_pathPiece()
{
	printf "%s" "$1" | awk '
BEGIN {
	srand()
	FS=""
	RS="n/o/m/a/t/c/h" rand()
	OFS=""
	ORS=""
	
	for (n = 0; n < 256; n++)
	{
		ord[sprintf("%c", n)] = n
		hex[sprintf("%c", n)] = "%" sprintf("%02X", n)
	}
}

{
	for (i = 1; i <= NF; i++)
	{
		x=ord[$i]
		
		# Unreserved characters
		if ( (x >= 48 && x <= 57) || (x >= 65 && x <= 90) || (x >= 97 && x <= 122) || (x == 45 || x == 46 || x == 95 || x == 126) )
		{
			printf("%s", $i)
		}
		else
		{
			printf("%s", hex[$i])
		}
	}
}'
}

core_dependency_requires '*' curl
urlencode_form()
{
	# newer versions return 0, older versions 3
	set +e
	local data="$(curl --silent --output /dev/null --write-out '%{url_effective}' --get --url '' --data-urlencode "$pathPiece")"
	set -e
	printf '%s' "${data##/?}"
}

# http://tools.ietf.org/html/rfc6570#section-2.1  is a bit silly
urlencode_literal()
{
	local uriFragment="$1"
	core_message WARN "We currently do not URI-encode URL template fragments"
	
	# Character-by-character conversion is required
	# Convert: CTL SP " ' < > \ ^ ` |
	# Convert only if not a percent encoding: %
	# Convert but impossible: { }  (as used to delimit expresions)!
	
	printf '%s' "$uriFragment"
}
